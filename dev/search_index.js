var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = BaseType","category":"page"},{"location":"#BaseType","page":"Home","title":"BaseType","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for BaseType.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [BaseType]","category":"page"},{"location":"#BaseType.base_numeric_type-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"Home","title":"BaseType.base_numeric_type","text":"base_numeric_type(::Type{T}) where {T}\nbase_numeric_type(x::T)\n\nExtract the base numeric type from a numerical type T such as a measurement or a quantity.\n\nFor example,\n\nInput Type Output Type\nFloat32 Float32\nComplexF32 Float32\nMeasurement{Float32} Float32\nDual{BigFloat} BigFloat\nRational{Int8} Int8\nQuantity{Float32, ...} Float32\nQuantity{Measurement{Float32}, ...} Float32\nDual{Complex{Float32}} Float32\n\nThe standard behavior is to return the first type parameter, or, if that type has parameters of its own (such as Dual{Complex{Float32}}), to recursively take the first type parameter until a non-parameterized type is found.\n\n\n\n\n\n","category":"method"}]
}
